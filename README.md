# Конспект по работе с Git

[Скачать git](https://git-scm.com/)

### Начало работы с Git:

-   `Git Bash` - приложение для работы с Git на Windows
-   `git --version` - информация об установленной версии git
-   `git config --global user.name "Alex Ivanov"` - задать глобальное имя пользователя Git
-   `git config --global user.email "email@domain.com"` - задать глобальный email пользователя Git
-   `mkdir dir_name` - создать папку dir_name в текущей директории
-   `cd dir_name` - перейти в папку dir_name
-   `git init` - инициализация репозитория в текущей директории

### Коммиты

-   `nano text.txt` - создание текстового файла
-   `git add test.txt` - добавить файл к отслеживанию
-   `git commit` - сделать коммит (опубликовать последнюю версию отслеживаемых файлов)
-   `gitk` - просмотр изменений

### Проверка состояния

-   `git status` - информация о текущем статусе репозитория

### Индексация файлов

-   `git add <filename>` - добавление файла к индексации Git
-   `git add .` - добавление всех файлов в текущей директории

### История коммитов

-   `git log` - вывод истории (лога) всех коммитов текущего репозитория
-   `git log --pretty=oneline` - вывод каждого коммита в одну строку (краткий формат)
-   `git log --max-count=3` - вывод последних трёх коммитов
-   `git log --all` - вывод всех коммитов
-   `git log --author="kimikanna"` - вывод коммитов, у которых автор kimikanna
-   `git log --pretty=format:"%h - %s : %ad [%an]" --date=short` - задать свой формат вывода, например: `3fd516f - New commit : 2024-08-03 [kimikanna]`

### git checkout

-   `git checkout 084ff06` - откатиться к коммиту с хешем 084ff06
-   `git checkout main` - вернуться на главную ветку

### Отмена индексированных файлов

-   `git reset HEAD test.txt` - откат последних изменений файла text.txt к версии HEAD (то есть к состоянию на момент последнего коммита)
-   `git checkout test.txt` - завершение отката (чтобы локальная версия нашего файла test.txt совпадала с закоммиченной)

### Отмена коммита

-   `git revert HEAD --no-edit` - откатить последний коммит

### Решение конфликтов

-   `git revert --abort` - отменить попытку отката
-   `git revert --continue` - продолжить откат после того как убедились, что все файлы в нужном состоянии (при возникновении конфликта)

### Ветвление

-   `git branch` - просмотр всех текущих веток
-   `git checkout -b newbranch` - создание новой ветки

    > Ветвление используется для удобства разработки, например, ветка "main" - это рабочая версия репозитория, которая сейчас в проде, а в ветке "dev" происходит активная разработка, которая никак не мешает ветке "main".

### Слияние веток

-   `git merge dev` - слияние ветки dev в текущую ветку

    > В случае merge конфликта (например, если один и тот же файл был изменён в обеих ветках по-разному), нужно зайти в этот файл, отредактировать его так, как нам это необходимо, после чего выполнить команды `git add` и затем `git commit` **без комментария**, чтобы комментарий о слиянии двух веток сгененрировался автоматически.

### Git rebase - отличия от Git merge

-   `git rebase dev` - влить ветку dev в текущую ветку

    > Основное отличие `git rebase` от `git merge` в том, что история вливаемой ветки появляется в `git log` позже изменений в ветке main, т.е. хронология изменений не сохраняется. Тогда как `git merge` сохранил бы полную историю изменений в хронологическом порядке (по времени изменения, от раннего к позднему).

### Удалённый репозиторий

-   `git clone <url>` - клонирование из удалённого репозитория в локальный
-   `git remote add origin <url>` - связать локальный репозиторий с удалённым

### Загружаем изменения в удалённый репозиторий

-   `git push` или `git push origin main` - отправить все закоммиченные изменения ветки main в удалённый репозиторий
-   `git push origin dev` - запушить дополнительную ветку `dev` в текущий удалённый репозиторий

### Обновляем код манерой merge и rebase

-   `git pull origin main` или `git pull --merge origin main` - вытащить изменения ветки `main` из удалённого репозитория
-   `git pull --rebase origin main` - работает так же, как `--merge`, но без сохранения хронологии: все локальные изменения будут добавлены в конец истории (после всех коммитов удалённого репозитория), даже если они были сделаны раньше.

    > Изпользовать флаг `--rebase` удобно, когда локально было выполнено множество изменений, и их нужно накатить "поверх" того, что сейчас находится в удалённом репозитории. В зависимости от ситуации, это может упростить разрешение возможных конфликтов при слиянии.

### Origin и stash

-   `git stash` - позволяет временно поместить непроиндексированные гитом файлы "в корзину", чтобы выполнить, например, `git pull --rebase`, без учёта последних (незакоммиченных) локальных изменений.
-   `git stash pop` - "достать" файлы из стеша.

    > При попытке выполнить `git pull` с флагом `--rebase`, в случае, если у нас есть незакоммиченные изменения, как в локальном, так и в удалённом репозитории, получим ошибку: `error: cannot pull with rebase: You have unstaged changes.` Для того, чтобы этого избежать, нужно либо закоммитить все локальные изменения, либо поместить их в `stash`, либо выполнить `git pull` без флага `--rebase` (или `git pull` с флагом `--merge`, это одно и то же). В этом случае произойдёт слияние двух версий.

-   `git stash list` - просмотр содержимого "корзины" (стеша).
